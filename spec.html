<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Decorators proposal
stage: 2
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons, Yehuda Katz, Brian Terlson
</pre>
<style>
emu-example figure {
  align-items: initial;
  width: 100%;
}

emu-note {
  display: block;
  border-left-color: #474747;
}

emu-note span.note {
  display: inline-block;
  color: #fff;
  background-color: #474747;
  width: initial;
  padding-right: 50px;
}

emu-note div.note-contents {
  padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #900;
}
emu-note[type=editor] span.note {
  background-color: #900;
}

emu-example {
  border-left: 5px solid #006387;
  margin: 1em 0;
}

emu-example figure figcaption:first-child {
  display: inline-block;
  color: #fff;
  background-color: #006387;
  margin: 0;
  padding: 0 50px 0 5px;
  font-weight: normal;
  text-transform: uppercase;
  margin-left: -5px;
}

emu-example figure figcaption:nth-child(2) {
  margin: 0;
  padding: 0;
  padding-left: 5px;
  margin-left: -5px;
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 10px;
}

emu-example p:nth-of-type(1) {
  margin-top: 0;
}

emu-example figure {
  padding-left: 5px;
  display: block;
  margin: 0;
}

emu-example pre {
  margin: 0;
}
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This proposal adds decorators to JavaScript. It incorporates features needed to make decorators work with the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> and <a href="https://littledan.github.io/proposal-private-methods">private methods</a>. See <a href="https://github.com/tc39/proposal-decorators">the explainer</a> for an overview.</p>

  <p>This document is phrased as a diff against the previous <a href="https://littledan.github.io/proposal-private-methods">private methods</a> proposal, which is in turn a diff against the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> proposal.</p>
</emu-intro>


<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-clause id=sec-new-syntax>
    <h1>New Productions</h1>

    <emu-grammar>
      DecoratorList[Yield, Await] :
        DecoratorList[?Yield, ?Await]? Decorator[?Yield, ?Await]

      Decorator[Yield, Await] :
        `@` DecoratorMemberExpression[?Yield, ?Await]
        `@` DecoratorCallExpression[?Yield, ?Await]

      DecoratorMemberExpression[Yield, Await] :
        IdentifierReference[?Yield, ?Await]
        DecoratorMemberExpression[?Yield, ?Await] `.` IdentifierName
        `(` Expression[+In, ?Yield, ?Await] `)`

      DecoratorCallExpression[Yield, Await] :
        DecoratorMemberExpression Arguments[?Yield, ?Await]
    </emu-grammar>
  </emu-clause>

  <emu-clause id=sec-updated-syntax>
    <h1>Updated Productions</h1>

    <emu-grammar>
      ClassElement[Yield, Await] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> FieldDefinition[?Yield, ?Await] `;`
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` FieldDefinition[?Yield, ?Await] `;`

      ClassDeclaration[Yield, Await, Default] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] <ins>DecoratorList[?Yield, ?Await]?</ins> `class` ClassTail[?Yield, ?Await]
    </emu-grammar>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-internal-algorithms">
<h1>Modified class algorithms</h1>

  <emu-clause id="runtime-semantics-class-definition-evaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameter _className_ and optional parameter _decorators_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. <ins>Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.</ins>
      1. <ins>Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).</ins>
      1. <ins>Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.</ins>
      1. <ins>If |ClassBody_opt| is present, then</ins>
        1. <ins>For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,</ins>
          1. <ins>Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).</ins>
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.</ins>
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let <del>_methods_</del><ins>_elements_</ins> be a new empty List.
      1. Else, let <del>_methods_</del><ins>_definitions_</ins> be <del>NonConstructorMethodDefinitions</del><ins>NonConstructorElementDefinitions</ins> of |ClassBody|. <ins>NOTE: Simply renaming this internal algorithm will be enough; it includes fields.</ins>
      1. <ins>Let _elements_ be a new empty List.</ins>
      1. For each |ClassElement| <del>_m_</del><ins>_d_</ins> in order from <del>_methods_</del><ins>_definitions_</del>,
        1. <del>If IsStatic of _m_ is *false*, then</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _proto_ and *false*.</del>
        1. <del>Else,</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _F_ and *false*.</del>
        1. <ins>Let _newElements_ be the result of performing ClassElementEvaluation for _d_ with arguments _F_, _true_, and ~empty~.</ins>
        1. If <del>_status_</del><ins>_newElements_</ins> is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
          1. Return Completion(_status_).
        1. <ins>Append _newElements_ to _elements_</ins>
      1. <ins>Let _elements_ be CoalesceClassElements(_elements_).</ins>
      1. <ins>If _decorators_ is not provided, let _decorators_ be a new empty List.</ins>
      1. <ins>Let _decorated_ be ? DecorateClass(_elements_, _decorators_).</ins>
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. <ins>Set the value of _F_'s [[Elements]] internal slot to _decorated_.[[Elements]].</ins>
      1. <ins>Perform ? InitializeClassElements(_F_, _proto_).</ins>
      1. <del>Return _F_.</del>
      1. <ins>Return ? RunClassFinishers(_F_, _decorated_.[[Finishers]]).</ins>
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-method-definitions-runtime-semantics-propertydefinitionevaluation">
    <h1>Runtime Semantics: ClassElementEvaluation</h1>
    <p>With parameters _homeObject_, _enumerable_ and _placement_.</p>
    <p>ClassElementEvaluation returns a List of Records of the form { [[Kind]]: `"method"` or `"field"`, [[Key]]: Property Key or Private Name, [[Descriptor]]: a Property Descriptor, [[Placement]]: `"static"`, `"prototype"` or `"own"`, [[Initializer]]: optional function for initial value which exists only for fields, [[Decorators]]: optional List of decorator functions }.</p>
    <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> MethodDefinition</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ?</ins> ClassElementEvaluation of |MethodDefinition| with arguments ! Get(_homeObject_, `"prototype"`),_enumerable_, and `"prototype"`.
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
    </emu-alg>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` MethodDefinition</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ?</ins> ClassElementEvaluation of |MethodDefinition| with arguments _homeObject_, _enumerable_ and `"static"`.
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
    </emu-alg>
  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ? ClassFieldDefinitionEvaluation of FieldDefinitionList with parameters `"static"` and _homeObject_.</ins>
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
  </emu-alg>

  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ? ClassFieldDefinitionEvaluation of FieldDefinitionList with parameters `"own"` and ! Get(_homeObject_, `"prototype"`).</ins>
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
  </emu-alg>

  </emu-clause>


    <!-- es6num="14.5.15" -->
    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation">
      <h1>Runtime Semantics: BindingClassDeclarationEvaluation</h1>
      <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
        1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
        1. Let _className_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments _className_<ins> and _decorators</ins>.
        1. ReturnIfAbrupt(_value_).
        1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
        1. If _hasNameProperty_ is *false*, perform SetFunctionName(_value_, _className_).
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_className_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` ClassTail</emu-grammar>
      <emu-alg>
        1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
        1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
        1. Return the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* <ins>and _decorators_</ins>.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and the setting of a name property and establishing its binding are handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

  <emu-clause id="sec-coalesce-getter-setter" aoid=CoalesceGetterSetter>
    <h1>CoalesceGetterSetter ( _element_, _other_ )</h1>
    <emu-alg>
      1. Assert: IsAccessorDescriptor(_other_.[[Descriptor]]) and IsAccessorDescriptor(_element_.[[Descriptor]]) are both *true*,
      1. If _element_.[[Descriptor]] has a [[Get]] field,
        1. Set _other_.[[Descriptor]].[[Get]] to _element_.[[Descriptor]].[[Get]].
      1. Otherwise,
        1. Assert: _element_.[[Descriptor]] has a [[Set]] field.
        1. Set _other_.[[Descriptor]].[[Set]] to _element_.[[Descriptor]].[[Set]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-coalesce-class-elements" aoid="CoalesceClassElements">
    <h1>CoalesceClassElements ( _elements_ )</h1>
    <emu-alg>
      1. Let _newElements_ be an empty List.
      1. For _element_ in _elements_,
        1. If _element_.[[Kind]] is `"method"` and _newElements_ contains a Record _other_ where _other_.[[Kind]] is `"method"`, SameValue(_other_.[[Key]], _element_.[[Key]]) is *true*, and _other_.[[Placement]] is _element_.[[Placement]],
          1. If _element_.[[Decorators]] is not empty,
            1. If _other_.[[Decorators]] is not empty, throw a *ReferenceError* exception.
            1. Set _other_.[[Decorators]] to _element_.[[Decorators]].
          1. If IsDataDescriptor(_element_.[[Descriptor]]) is *true* or IsDataDescriptor(_other_.[[Descriptor]]) is *true*, then
            1. Assert: _element_.[[Key]] is not a Private Name.
            1. Assert: _element_.[[Descriptor]].[[Configurable]] is *true*, and _other_.[[Descriptor]].[[Configurable]] is *true*.
            1. Set _other_.[[Descriptor]] to _element_.[[Descriptor]].
          1. Else,
            1. Perform ! CoalesceGetterSetter(_element_, _other_).
        1. Otherwise, append _element_ to _newElements_.
      1. Return _newElements_.
    </emu-alg>
    <emu-note>In the case of public class elements, coalescing corresponds in semantics to ValidateAndApplyPropertyDescriptor. Note that this algorithm only coalesces method and accessor declarations, and it leaves field declarations as is.</emu-note>
  </emu-clause>

</emu-clause>


</emu-clause>

  <emu-clause id="sec-private-name-type-and-objects">
    <h1>PrivateName Type and Objects</h1>

    <emu-clause id="sec-ecmascript-language-types-private-name-type">
      <h1>The PrivateName Type</h1>
      <p>The PrivateName type is the set of all values which may be used as a Private Name in operations such as PrivateNameget.</p>
      <p>Each possible PrivateName value is unique and immutable.</p>
      <p>Each PrivateName value immutably holds an associated value called [[Description]] that is either *undefined* or a String value.</p>
    </emu-clause>

  <emu-clause id="sec-private-name-objects">
    <h1>PrivateName Objects</h1>
    <emu-clause id="sec-private-name-constructor">
      <h1>The Private Name Constructor</h1>
      <p>The Private Name constructor is the <dfn>%PrivateName%</dfn> intrinsic object and the initial value of the `PrivateName` property of the global object. When `PrivateName` is called as a function, it returns a new Private Name value.</p>
      <p>The `PrivateName` constructor is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an `extends` clause of a class definition but a `super` call to the `PrivateName` constructor will cause an exception.</p>

      <emu-clause id="sec-newprivatename" aoid="NewPrivateName">
        <h1>NewPrivateName ( _description_ )</h1>
        <emu-alg>
          1. Return a new unique PrivateName value whose [[Description]] value is _description_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-description" aoid=PrivateName>
        <h1>PrivateName ( [ _description_ ] )</h1>
        <p>When `PrivateName` is called with optional argument _description_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. If _description_ is *undefined*, let _descString_ be *undefined*.
          1. Else, let _descString_ be ? ToString(_description_).
          1. Return NewPrivateName(_descString_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-private-name-prototype-object">
      <h1>Properties of the PrivateName Prototype Object</h1>
      <p>The PrivateName prototype object is the intrinsic object <dfn>%PrivateNamePrototype%</dfn>. The PrivateName prototype object is an ordinary object. It is not a PrivateName instance and does not have a [[PrivateNameData]] internal slot.</p>
      <p>The value of the [[Prototype]] internal slot of the PrivateName prototype object is the intrinsic object %ObjectPrototype%.</p>

      <emu-clause id="sec-private-name.prototype.constructor">
        <h1>PrivateName.prototype.constructor</h1>
        <p>The initial value of `PrivateName.prototype.constructor` is the intrinsic object %PrivateName%.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-get">
        <h1>%PrivateNameGet%( _name_, _object_ )</h1>
        <p>%PrivateNameGet% is a per-realm built-in function object. When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _pn_ be ? ToPrivateName(_name_).
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldGet(_pn_, _object_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name-set">
        <h1>%PrivateNameSet% ( _name_, _object_, _value_ )</h1>
        <p>%PrivateNameSet% is a per-realm built-in function object. When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _pn_ be ? ThisPrivateName().
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldSet(_pn_, _object_, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.tostring">
        <h1>PrivateName.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return PrivateNameDescriptiveString(? ThisPrivateName()).
        </emu-alg>

        <emu-clause id="sec-private-namedescriptivestring" aoid="PrivateNameDescriptiveString">
          <h1>Runtime Semantics: PrivateNameDescriptiveString ( _sym_ )</h1>
          <p>When the abstract operation PrivateNameDescriptiveString is called with argument _sym_, the following steps are taken:</p>
          <emu-alg>
            1. Assert: Type(_sym_) is PrivateName.
            1. Let _desc_ be _sym_'s [[Description]] value.
            1. If _desc_ is *undefined*, let _desc_ be the empty string.
            1. Assert: Type(_desc_) is String.
            1. Return the result of concatenating the strings `"#"` and _desc_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.valueof">
        <h1>PrivateName.prototype.valueOf ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Return ? ThisPrivateName().
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype-@@toprimitive">
        <h1>PrivateName.prototype [ @@toPrimitive ] ( _hint_ )</h1>
        <p>This function is called by ECMAScript language operators to convert a PrivateName object to a primitive value. The allowed values for _hint_ are `"default"`, `"number"`, and `"string"`.</p>
        <p>When the `@@toPrimitive` method is called with argument _hint_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? ThisPrivateName().
        </emu-alg>
        <p>The value of the `name` property of this function is `"[PrivateName.toPrimitive]"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-this-private-name" aoid=ThisPrivateName>
        <h1>ThisPrivateName()</h1>
        <emu-alg>
          1. Let _p_ be the *this* value.
          1. Return ToPrivateName(_p_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name-to-private-name" aoid=ToPrivateName>
        <h1>ThisPrivateName(_p_)</h1>
        <emu-alg>
          1. If Type(_p_) is PrivateName, return _p_.
          1. If Type(_p_) is not Object, throw a *TypeError* exception.
          1. If _p_ does not have a [[PrivateNameData]] internal slot, throw a *TypeError* exception.
          1. Return _p_.[[PrivateNameData]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype-@@tostringtag">
        <h1>PrivateName.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"PrivateName"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-private-name-instances">
      <h1>Properties of PrivateName Instances</h1>
      <p>PrivateName instances are ordinary objects that inherit properties from the PrivateName prototype object. PrivateName instances have a [[PrivateNameData]] internal slot. The [[PrivateNameData]] internal slot is the PrivateName value represented by this PrivateName object.</p>
    </emu-clause>
    </emu-clause>

    <emu-clause id="sec-private-name-amended-algs">
      <h1>Amended internal algorithms for private names</h1>

    <emu-clause id="sec-toboolean" aoid="ToBoolean">
      <h1>ToBoolean ( _argument_ )</h1>
      <p>The abstract operation ToBoolean converts _argument_ to a value of type Boolean according to <emu-xref href="#table-10"></emu-xref>:</p>
      <emu-table id="table-10" caption="ToBoolean Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return *false*.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return *false*.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              If _argument_ is *+0*, *-0*, or *NaN*, return *false*; otherwise return *true*.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              If _argument_ is the empty String (its length is zero), return *false*; otherwise return *true*.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return *true*.
            </td>
          </tr>
          <tr>
            <td>
              <ins>PrivateName</ins>
            </td>
            <td>
              <ins>Return *true*.</ins>
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return *true*.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <!-- es6num="7.1.3" -->
    <emu-clause id="sec-tonumber" aoid="ToNumber">
      <h1>ToNumber ( _argument_ )</h1>
      <p>The abstract operation ToNumber converts _argument_ to a value of type Number according to <emu-xref href="#table-11"></emu-xref>:</p>
      <emu-table id="table-11" caption="ToNumber Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return *NaN*.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return *+0*.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              If _argument_ is *true*, return 1. If _argument_ is *false*, return *+0*.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return _argument_ (no conversion).
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              See grammar and conversion algorithm below.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              <ins>PrivateName</ins>
            </td>
            <td>
              <ins>Throw a *TypeError* exception.</ins>
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              <p>Apply the following steps:</p>
              <emu-alg>
                1. Let _primValue_ be ? ToPrimitive(_argument_, hint Number).
                1. Return ? ToNumber(_primValue_).
              </emu-alg>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      </emu-clause>

    <!-- es6num="7.1.12" -->
    <emu-clause id="sec-tostring" aoid="ToString">
      <h1>ToString ( _argument_ )</h1>
      <p>The abstract operation ToString converts _argument_ to a value of type String according to <emu-xref href="#table-12"></emu-xref>:</p>
      <emu-table id="table-12" caption="ToString Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return `"undefined"`.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return `"null"`.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              <p>If _argument_ is *true*, return `"true"`.</p>
              <p>If _argument_ is *false*, return `"false"`.</p>
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              See <emu-xref href="#sec-tostring-applied-to-the-number-type"></emu-xref>.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              <ins>PrivateName</ins>
            </td>
            <td>
              <ins>Throw a *TypeError* exception.</ins>
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              <p>Apply the following steps:</p>
              <emu-alg>
                1. Let _primValue_ be ? ToPrimitive(_argument_, hint String).
                1. Return ? ToString(_primValue_).
              </emu-alg>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-toobject" aoid="ToObject">
      <h1>ToObject ( _argument_ )</h1>
      <p>The abstract operation ToObject converts _argument_ to a value of type Object according to <emu-xref href="#table-13"></emu-xref>:</p>
      <emu-table id="table-13" caption="ToObject Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return a new Boolean object whose [[BooleanData]] internal slot is set to _argument_. See <emu-xref href="#sec-boolean-objects"></emu-xref> for a description of Boolean objects.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return a new Number object whose [[NumberData]] internal slot is set to _argument_. See <emu-xref href="#sec-number-objects"></emu-xref> for a description of Number objects.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return a new String object whose [[StringData]] internal slot is set to _argument_. See <emu-xref href="#sec-string-objects"></emu-xref> for a description of String objects.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return a new Symbol object whose [[SymbolData]] internal slot is set to _argument_. See <emu-xref href="#sec-symbol-objects"></emu-xref> for a description of Symbol objects.
            </td>
          </tr>
          <tr>
            <td>
              <ins>PrivateName</ins>
            </td>
            <td>
              <ins>Return a new PrivateName object whose [[PrivateNameData]] internal slot is set to _argument_. See <emu-xref href="#sec-private-name-objects"></emu-xref> for a description of PrivateName objects.</ins>
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-requireobjectcoercible" aoid="RequireObjectCoercible">
      <h1>RequireObjectCoercible ( _argument_ )</h1>
      <p>The abstract operation RequireObjectCoercible throws an error if _argument_ is a value that cannot be converted to an Object using ToObject. It is defined by <emu-xref href="#table-14"></emu-xref>:</p>
      <emu-table id="table-14" caption="RequireObjectCoercible Results">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              <ins>PrivateName</ins>
            </td>
            <td>
              <ins>Return _argument_.</ins>
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>The `typeof` Operator</h1>

      <!-- es6num="12.5.6.1" -->
      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _val_ be the result of evaluating |UnaryExpression|.
          1. If Type(_val_) is Reference, then
            1. If IsUnresolvableReference(_val_) is *true*, return `"undefined"`.
          1. Set _val_ to ? GetValue(_val_).
          1. Return a String according to <emu-xref href="#table-35"></emu-xref>.
        </emu-alg>
        <emu-table id="table-35" caption="typeof Operator Results">
          <table>
            <tbody>
            <tr>
              <th>
                Type of _val_
              </th>
              <th>
                Result
              </th>
            </tr>
            <tr>
              <td>
                Undefined
              </td>
              <td>
                `"undefined"`
              </td>
            </tr>
            <tr>
              <td>
                Null
              </td>
              <td>
                `"object"`
              </td>
            </tr>
            <tr>
              <td>
                Boolean
              </td>
              <td>
                `"boolean"`
              </td>
            </tr>
            <tr>
              <td>
                Number
              </td>
              <td>
                `"number"`
              </td>
            </tr>
            <tr>
              <td>
                String
              </td>
              <td>
                `"string"`
              </td>
            </tr>
            <tr>
              <td>
                Symbol
              </td>
              <td>
                `"symbol"`
              </td>
            </tr>
            <tr>
              <td>
                <ins>PrivateName</ins>
              </td>
              <td>
                <ins>`"privatename"`</ins>
              </td>
            </tr>
            <tr>
              <td>
                Object (ordinary and does not implement [[Call]])
              </td>
              <td>
                `"object"`
              </td>
            </tr>
            <tr>
              <td>
                Object (standard exotic and does not implement [[Call]])
              </td>
              <td>
                `"object"`
              </td>
            </tr>
            <tr>
              <td>
                Object (implements [[Call]])
              </td>
              <td>
                `"function"`
              </td>
            </tr>
            <tr>
              <td>
                Object (non-standard exotic and does not implement [[Call]])
              </td>
              <td>
                Implementation-defined. Must not be `"undefined"`, `"boolean"`, `"function"`, `"number"`, `"symbol"`, or `"string"`.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <emu-note>
          <p>Implementations are discouraged from defining new `typeof` result values for non-standard exotic objects. If possible `"object"` should be used for such objects.</p>
        </emu-note>
      </emu-clause>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="decorator-semantics">
  <h1>Decorator semantics</h1>
  <emu-clause id=sec-decorator-functions>
    <h1>Decorator Functions</h1>
    <p>A <dfn>decorator function</dfn> is a function that takes and returns either a element descriptor or a class descriptor. The body of a decorator function modifies and returns the descriptor it receives to change the semantics of the decorated entity. Descriptor types can be differentiated by their `kind` property, which is either `"method"`, `"field"` or `"class"`. Descriptors also have a @@toStringTag property which is of the form `"Kind Descriptor"`, where `"Kind"` is replaced by the `kind` property with the first letter capitalized; this property helps differentiate them from other objects.</p>
    <emu-clause id=sec-decorator-functions-element-descriptor>
      <h1>Element Descriptors</h1>
      <p>An <dfn>element descriptor</dfn> describes an element of a class or object literal and has the following shape:</p>
      <pre><code class=typescript>
        interface ElementDesciptor {
          kind: "method" or "field"
          key: String, Symbol or Private Name,
          placement: "static", "prototype", or "own"
          descriptor: PropertyDescriptor,
          initializer?: Function
          extras?: ElementDescriptor[]
          finisher?: (klass): undefined or constructor;
        }
      </code></pre>
      The `finisher` and `extra` fields are only present when returning from user code, and are not given as an argument to them, or logically part of the descriptor.
    </emu-clause>
    <emu-clause id=sec-decorator-functions-class-descriptor>
      <h1>Class Descriptors</h1>
      <p>A <dfn>class descriptor</dfn> describes a class and has the following shape:</p>
      <pre><code class=typescript>
        interface ClassDesciptor {
          kind: "class"
          elements: ElementDescriptor[]
          finisher?: (klass): undefined or constructor;
        }
      </code></pre>
    </emu-clause>
  </emu-clause>

    <emu-clause id=sec-decorator-runtime-semantics-decoratorevaluation aoid=DecoratorEvaluation>
      <h1>Runtime Semantics: DecoratorEvaluation</h1>
      <emu-grammar>Decorator : `@` DecoratorMemberExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the result of reparsing |DecoratorMemberExpression| as a |MemberExpression|.
        1. Let _ref be the result of evaluating _expr_.
        1. Let _value be ? GetValue(_ref_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>Decorator : `@` DecoratorCallExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the result of reparsing |DecoratorCallExpression| as a |CallMemberExpression|.
        1. Let _ref be the result of evaluating _expr_.
        1. Let _value be ? GetValue(_ref_).
        1. Return _value_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-method-definitions-runtime-semantics-decoratorlistevaluation aoid=DecoratorListEvaluation>
      <h1>Runtime Semantics: DecoratorListEvaluation</h1>
      <emu-grammar>DecoratorList : DecoratorList[?Yield]? Decorator[?Yield]</emu-grammar>
      <emu-alg>
        1. If |DecoratorList| is present, then let _leftValue_ be ? DecoratorListEvaluation(|DecoratorList|).
        1. Else, let _leftValue_ be a new empty List.
        1. Let _rightValue_ be ? DecoratorEvaluation(|Decorator|).
        1. Append _rightValue_ to the end of _leftValue_.
        1. Return _leftValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-run-class-finishers aoid=RunClassFinishers>
      <h1>RunClassFinishers ( constructor, finishers )</h1>
      <emu-alg>
        1. For each _finisher_ in _finishers_, do
          1. Let _newConstructor_ be Call( _finisher_, *undefined*, « _constructor_ »).
          1. If _newConstructor_ is not *undefined*,
            1. If IsConstructor(_newConstructor_) is *false*, throw a *TypeError* exception.
            1. Let _constructor_ be _newConstructor_.
        1. Return _constructor_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-class aoid=DecorateClass>
      <h1>DecorateClass ( elements, decorators )</h1>
      <emu-alg>
        1. Let _newElements_, _finishers_, and _keys_ each be a new empty List.
        1. For each _element_ in _elements_, do
          1. Append _element_.[[Key]] to _keys_.
        1. For each _element_ in _elements_, do
          1. Let _elementFinishersExtras_ be ? DecorateElement(_element_, _keys_).
          1. Append _elementFinishersExtras_.[[Element]] to _newElements_.
          1. Concatenate _elementFinishersExtras_.[[Extras]] onto _newElements_.
          1. Concatenate _elementFinishersExtras_.[[Finishers]] onto _finishers_.
        1. Let _result_ be ? DecorateConstructor(_newElements_, _decorators_).
        1. Set _result_.[[Finishers]] to the concatenation of _finishers_ and _result_.[[Finishers]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-element aoid=DecorateElement>
      <h1>DecorateElement ( element, keys )</h1>
      <p>With parameters _element_, a Class Element and _keys_, a List of Property Keys and Private Names.</p>
      <emu-alg>
        1. Let _extras_ be a new empty List.
        1. Let _finishers_ be a new empty List.
        1. For each _decorator_ in element_.[[Decorators]], in reverse list order do
          1. Assert: _element_.[[Key]] is an element of _keys_.
          1. Remove _element_.[[Key]] from _keys_.
          1. Let _elementObject_ be ? FromElementDescriptor(_element_).
          1. Let _elementFinisherExtrasObject_ be ? Call(_decorator_, *undefined*, « _elementObject_, %PrivateNameGet%, %PrivateNameSet% »).
          1. Let _elementFinisherExtras_ be ? ToElementDescriptor(_elementFinisherExtrasObject_).
          1. Let _element_ be _elementFinisherExtras_.[[Element]].
          1. If _element_.[[Key]] is an element of _keys_, throw a *TypeError* exception.
          1. Otherwise, append _element_.[[Key]] to _keys_.
          1. If _elementFinisherExtras_.[[Finisher]] is not *undefined*, then
            1. Append _elementFinisherExtras_.[[Finisher]] to the end of _finishers_.
            1. NOTE: Finishers are not passed forward to the next decorator.
          1. Let _newExtras_ be _elementFinisherExtras_.[[Extras]]
          1. If _newExtras_ is not *undefined*, then
            1. For each _extra_ of _newExtras_, do
              1. If _extra_.[[Key]] is an element of _keys_, throw a *TypeError* exception.
              1. Otherwise, append _extra_.[[Key]] to _keys_.
            1. Concatenate _newExtras_ onto _extras_.
        1. Return the Record {[[Element]]: _element_, [[Extras]]: _extras_, [[Finishers]]: _finishers_}.
      </emu-alg>
    </emu-clause>
    <emu-clause id=sec-decorate-constructor aoid=DecorateConstructor>
      <h1>DecorateConstructor ( elements, decorators )</h1>
      <p>With parameters _elements_, a List of Class Elements, and _decorators_, a List of decorator functions.</p>
      <emu-alg>
        1. Let _finishers_ be a new empty List.
        1. For each _decorator_ in _decorators_, in reverse list order do
          1. Let _obj_ be FromClassDescriptor(_elements_).
          1. Let _result_ be ? Call(_decorator_, *undefined*, « _obj_, %PrivateNameGet%, %PrivateNameSet% »).
          1. Let _elementsAndFinisher_ be ? ToClassDescriptor(_result_).
          1. If _elementsAndFinisher_.[[Finisher]] is not *undefined*,
            1. Append _elementsAndFinisher_.[[Finisher]] to _finishers_.
          1. If _elementsAndFinisher_.[[Elements]] is not *undefined*,
            1. Set _elements_ to _elementsAndFinisher_.[[Elements]].
            1. If there are two class elements _a_ and _b_ in _elements_ such that _a_.[[Key]] is _b_.[[Key]], throw a *TypeError* exception.
        1. Return the Record { [[Elements]]: _elements_, [[Finishers]]: _finishers_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-from-element-descriptors" aoid=FromElementDescriptors>
      <h1>FromElementDescriptors ( _elements_ )</h1>
      <emu-alg>
        1. Let _elementObjects_ be a new empty List.
        1. For each _element_ in _elements_, do
          1. Append FromElementDescriptor(_element_) to _elementObjects_.
        1. Return CreateArrayFromList(_elementObjects_).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-element-descriptor aoid=FromElementDescriptor>
      <h1>FromElementDescriptor ( _element_ )</h1>
      <emu-alg>
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. If _element_.[[Kind]] is `"method"`,
          1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Method Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Otherwise,
          1. Assert: _element_.[[Kind]] is `"field"`.
          1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Field Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, _element_.[[Kind]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"key"`, _element_.[[Key]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"placement"`, _element_.[[Placement]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"descriptor"`, ! FromPropertyDescriptor(_element_.[[Descriptor]])).
        1. If _element_.[[Kind]] is `"field"`,
          1. Let _initializer_ be _element_.[[Initializer]].
          1. If _initializer_ is ~empty~, set _initializer_ to *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"initializer"`, _initializer_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-to-element-descriptors" aoid=ToElementDescriptor>
      <h1>ToElementDescriptors ( _elementsObject_ )</h1>
      <emu-alg>
        1. If _elementsObject_ is *undefined*, return *undefined*.
        1. Let _elements_ be a new empty List.
        1. Let _elementObjectList_ be ? IterableToList(_elementsObject_).
        1. For each _elementObject_ in _elementObjectList_, do
          1. Append ToElementDescriptor(_elementObject_) to _elements_.
        1. Return _elements_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-element-descriptor aoid=ToElementDescriptor>
      <h1>ToElementDescriptor ( _elementObject_ )</h1>
      <p>With parameter _elementObject_, returns a Record containing three values: { [[Element]]: a class Element Descriptor, [[Extras]]: an iterable of other elements, [[Finisher]]: a Function or *undefined* }.</p>
      <emu-alg>
        1. Let _kind_ be ? ToString(? Get(_elementObject_, `"kind"`)).
        1. If _kind_ is not one of `"method"` or `"field"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_elementObject_, `"key"`).
        1. Set _key_ to ? ToPrimitive(_key_, hint String).
        1. If _key_ is not a Private Name, set _key_ to ? ToPropertyKey(_key_).
        1. Let _placement_ be ? ToString(? Get(_elementObject_, `"placement"`)).
        1. If _placement_ is not one of `"static"`, `"prototype"`, or `"own"`, throw a *TypeError* exception.
        1. Let _descriptor_ be ? ToPropertyDescriptor(? Get(_elementObject_, `"descriptor"`)).
        1. Let _initializer_ be ? Get(_elementObject_, `"initializer"`).
        1. Let _finisher_ be ? Get(_elementObject_, `"finisher"`).
        1. If IsCallable(_finisher_) is *false* and _finisher_ is not *undefined*, throw a *TypeError* exception.
        1. Let _extrasObject_ be ? Get(_elementObject_, `"extras"`).
        1. Let _extras_ be ? ToElementDescriptors(_extrasObject_).
        1. Let _elements_ be ? Get(_elementObject_, `"elements"`).
        1. If _elements_ is not *undefined*, throw a *TypeError* exception.
        1. If _kind_ not `"field"`,
          1. If _initializer_ is not *undefined*, throw a *TypeError* exception.
        1. If _key_ is a Private Name,
          1. If _descriptor_.[[Enumerable]] is *true*, throw a *TypeError* exception.
          1. If _descriptor_.[[Configurable]] is *true*, throw a *TypeError* exception.
          1. If _placement_ is `"prototype"` or `"static"`, throw a *TypeError* exception.
        1. If _kind_ is `"field"`,
          1. If _descriptor_ has a [[Get]], [[Set]] or [[Value]] internal slot, throw a *TypeError* exception.
        1. Let _element_ be {[[Kind]]: _kind_, [[Key]]: _key_, [[Placement]]: _placement_, [[Descriptor]]: _descriptor_}.
        1. If [[Kind]] is `"field"`, set _element_.[[Initializer]] to _initializer_.
        1. Return the Record { [[Element]]: _element_, [[Finisher]]: _finisher_, [[Extras]]: _extras_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-class-descriptor aoid=FromClassDescriptor>
      <h1>FromClassDescriptor ( _elements_ )</h1>
      <emu-alg>
        1. Let _elementsObjects_ be FromElementDescriptors(_elements_).
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Class Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, `"class"`).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"elements"`, _elementsObjects_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-class-descriptor aoid=ToClassDescriptor>
      <h1>ToClassDescriptor ( _obj_ )</h1>
      <emu-alg>
        1. Let _kind_ be ? ToString(? Get(_obj_, `"kind"`).
        1. If _kind_ is not `"class"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_obj_, `"key"`).
        1. If _key_ is not *undefined*, throw a *TypeError* exception.
        1. Let _placement_ be ? Get(_obj_, `"placement"`).
        1. If _placement_ is not *undefined*, throw a *TypeError* exception.
        1. Let _descriptor_ be ? Get(_obj_, `"descriptor"`).
        1. If _descriptor_ is not *undefined*, throw a *TypeError* exception.
        1. Let _initializer_ be ? Get(_obj_, `"initializer"`).
        1. If _initializer_ is not *undefined*, throw a *TypeError* exception.
        1. Let _extras_ be ? Get(_obj_, `"extras"`).
        1. If _extras_ is not *undefined*, throw a *TypeError* exception.
        1. Let _finisher_ be ? Get(_obj_, `"finisher"`).
        1. If _finisher_ is not *undefined*,
          1. If IsCallable(_finisher_) is *false*, throw a *TypeError* exception.
        1. Let _elementsObject_ be ? Get(_obj_, `"elements"`).
        1. Let _elements_ be ? ToElementDescriptors(_elementsObject_).
        1. Return the Record { [[Elements]]: _elements_, [[Finisher]]: _finisher_ }.
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>
